/**
\page pic24_details PIC24/dsPIC details

\tableofcontents

PIC24/dsPIC port implementation details

\section pic24_context_switch Context switch
The context switch is implemented using the external interrupt 0 (`INT0`). It
is handled completely by the kernel, application should never touch it.

\section pic24_interrupts Interrupts

For generic information about interrupts in TNeoKernel, refer to the page \ref
interrupts.

PIC24/dsPIC TNeoKernel port supports nested interrupts. It allows to specify
the range of *system interrupt priorities*. Refer to the section \ref
interrupt_types for details on what is <i>system interrupt</i>.

System interrupts use separate interrupt stack instead of the task's stack.
This approach saves a lot of RAM.

The range is specified by just a single number: `#TN_P24_SYS_IPL`, which
represents maximum *system interrupt priority*. Here is a list of available
priorities and their characteristics:

- priorities `[1 .. #TN_P24_SYS_IPL]`: 
  - Kernel services **are** allowed to call;
  - The macro `tn_p24_soft_isr()` <b>must</b> be used.
  - Separate interrupt stack is used by ISR;
  - Interrupts get disabled for short periods of time when modifying critical
    kernel data (for about 100 cycles or the like).
- priorities `[(#TN_P24_SYS_IPL + 1) .. 6]`:
  - Kernel services **are not** allowed to call;
  - The macro `tn_p24_soft_isr()` <b>must not</b> be used.
  - Task's stack is used by ISR;
  - Interrupts are not disabled when modifying critical kernel data, but they
    are disabled for 4..8 cycles by `disi` instruction when entering/exiting
    system ISR: we need to safely modify `SP` and `SPLIM`.
- priority `7`:
  - Kernel services **are not** allowed to call;
  - The macro `tn_p24_soft_isr()` <b>must not</b> be used.
  - Task's stack is used by ISR;
  - Interrupts are never disabled by the kernel. Note that `disi` instruction
    leaves interrupts of priority 7 enabled. 

The kernel provides C-language macro for calling C-language **system**
interrupt service routines.

Usage is as follows:

\code{.c}
/* 
 * Timer 1 interrupt handler using software interrupt context saving,  
 * PSV is handled automatically:
 */
tn_p24_soft_isr(_T1Interrupt, auto_psv)
{
   //-- clear interrupt flag
   IFS0bits.T1IF = 0;

   //-- do something useful
}
\endcode

\attention do **not** use this macro for non-system interrupt (that is, for
interrupt of priority higher than `#TN_P24_SYS_IPL`). Use standard way to
define it. If you violate this rule, debugger will be halted by the kernel when
entering ISR. In release build, CPU is just reset.


\section pic24_bfa Atomic access to the structure bit field

The problem with PIC24/dsPIC is that when we write something like:

\code{.c}
IPC0bits.INT0IP = 0x05;
\endcode

We actually have read-modify-write sequence which can be interrupted, so that
resulting data could be corrupted. PIC24/dsPIC port provides several macros
that offer atomic access to the structure bit field.

The kernel would not probably provide that kind of functionality, but 
TNeoKernel itself needs it, so, it is made public so that application can
use it too.

Refer to the page \ref tn_arch_pic24_bfa.h "Atomic bit-field access macros"
for details.


\section pic24_building Building

For generic information on building TNeoKernel, refer to the page \ref building.

MPLABX project for PIC24/dsPIC port resides in the
`src/arch/pic24_dspic/tneokernel_pic24_dspic.X` directory. This is a *library
project* in terms of MPLABX, so if you use MPLABX you can easily add it to your
main project by right-clicking `Libraries -> Add Library Project ...`.  

\attention there are two configurations of this project: <i>eds</i> and <i>
no_eds</i>, for devices with and without extended data space, respectively.
When you add library project to your application project, you should select
correct configuration for your device; otherwise, you get "undefined reference"
errors at linker step.

Alternatively, of course you can just build it and use
resulting `.a` file in whatever way you like.


*/
