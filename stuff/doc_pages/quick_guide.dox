/**
\page quick_guide Quick guide

\tableofcontents

This page contains quick guide on system startup and important implementation details.

\section usage_generic Using TNeoKernel in your application

The easiest way is to download version archive from [downloads page]
(https://bitbucket.org/dfrank/tneokernel/downloads): it contains `bin` folder
with library files for various platforms. These library files were built with
default configuration file (`src/tn_cfg_default.h`, see the section \ref
configuration_file).

If you use MPLABX, it is probably better to add <i>library project</i> to your
main project instead; library projects reside in the
`<tneokernel_path>/lib_project` directory.

In either case, all you need is the following:

- Add library file for appropriate platform to your project (or probably
  <i>library project</i> in case of MPLABX);
- Add C include path: `<tneokernel_path>/src`;
- Copy default configuration file as current configuration file: `cp
  <tneokernel_path>/src/tn_cfg_default.h <tneokernel_path>/src/tn_cfg.h`
  (for more information about configuration file and better ways to manage it,
  refer to the section \ref configuration_file)

That's all; you can use it in your project now. See below how to do this.

\attention If you need to change the configuration, you can't just edit
`tn_cfg.h` and keep using pre-built library file: you need to rebuild the
library after editing `tn_cfg.h`. Refer to the page \ref building for details.


\section time_ticks Time ticks

For the purpose of calculating timeouts, the kernel uses a time tick timer.  In
TNeoKernel, this time tick timer must to be a some kind of hardware timer that
produces interrupt for time ticks processing. Throughout this text, this timer
is referred to as *system timer*. The period of this timer  is determined by
user (typically 1 ms, but user is free to set different value). In the ISR for
this timer, it is only necessary to call the `tn_tick_int_processing()`
function:

\code{.c}
//-- example for PIC32, hardware timer 5 interrupt:
tn_p32_soft_isr(_TIMER_5_VECTOR)
{
   INTClearFlag(INT_T5);
   tn_tick_int_processing();
}
\endcode

\section starting_the_kernel Starting the kernel

### Quick guide on startup process

  - You allocate arrays for idle task stack and interrupt stack, there is a
    convenience macro `TN_STACK_ARR_DEF()` for that. It is good idea to
    consult the `#TN_MIN_STACK_SIZE` to determine stack sizes (see example
    below).
  - You provide callback function like `void init_task_create(void) { ... }`,
    in which at least one (and typically just one) your own task should be
    created and activated. This task should perform application initialization
    and create all the rest of tasks.  See details in `TN_CBUserTaskCreate()`.
  - You provide idle callback function to be called periodically from idle
    task. It's quite fine to leave it empty.
  - In the `main()` you should:
    - disable <i>system interrupts</i> by calling `tn_arch_int_dis()`;
    - perform some essential CPU configuration, such as oscillator settings and
      similar things. 
    - setup $(TN_SYS_TIMER_LINK) interrupt (from which
      `tn_tick_int_processing()` gets called)
    - call `tn_sys_start()` providing all necessary information: pointers to
      stacks, their sizes and your callback functions.
  - Kernel acts as follows:
    - performs all necessary housekeeping;
    - creates idle task;
    - calls your `TN_CBUserTaskCreate()` callback, in which your initial task
      is created with `#TN_TASK_CREATE_OPT_START` option;
    - performs first context switch (to your task with highest priority).
  - At this point, system operates normally: your initial task gets executed
    and you can call whatever system services you need. Typically, your initial
    task acts then as follows:
    - Perform initialization of various on-board peripherals (displays, flash
      memory chips, or whatever);
    - Initialize software modules used by application;
    - Create all the rest of your tasks (since everything is initialized
      already so that they can proceed with their job);
    - Eventually, perform its primary job (the job for which task was created
      at all).

### Basic example for PIC32

This example project can be found in the TNeoKernel repository, in the
`examples/basic/arch/pic32` directory.

\attention Before trying to build examples, please read \ref building page
carefully: you need to copy configuration file in the tneokernel directory to
build it. Each example has `tn_cfg_appl.h` file, and you should either create 
a symbolic link to this file from `tneokernel/src/tn_cfg.h` or just copy
this file as `tneokernel/src/tn_cfg.h`.

\include basic/arch/pic32/tn_pic32_example_basic.c

\section round_robin Round-robin scheduling

TNKernel has the ability to make round robin scheduling for tasks with
identical priority.  By default, round robin scheduling is turned off for
all priorities. To enable round robin scheduling for tasks on certain
priority level and to set time slices for these priority, user must call the
`tn_sys_tslice_set()` function.  The time slice value is the same for all
tasks with identical priority but may be different for each priority level.
If the round robin scheduling is enabled, every system time tick interrupt
increments the currently running task time slice counter. When the time
slice interval is completed, the task is placed at the tail of the ready to
run queue of its priority level (this queue contains tasks in the
$(TN_TASK_STATE_RUNNABLE) state) and the time slice counter is cleared. Then
the task may be preempted by tasks of higher or equal priority.

In most cases, there is no reason to enable round robin scheduling. For
applications running multiple copies of the same code, however, (GUI
windows, etc), round robin scheduling is an acceptable solution.

*/
