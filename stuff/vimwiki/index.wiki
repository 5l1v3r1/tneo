
= tnkernel_df dev =

== mods that don't change API ==

   * [X] remove `typedef`s, use `struct TNCamelCase` instead.
   * [X] `tn_common.h`: convert macros to enums.
   * [X] rename queue_... functions to list_.. (because it is actually a list, not a queue)
   * [X] rename `tn_list.h` to `tn_list.h` or something like that
   * [X] probably add bool/true/false
   * [X] Implement a kind of `list_for_each`
   * [ ] clear tn_sys c/h files up
   * [ ] implement deadlock detection (probably, with user-provided callback that will be called if something bad happens. Probably use this callback instead of TN_FATAL_ERROR)


== mods that DO change API ==

   * [ ] Add a destroy callback for each task, this callback (if not NULL) should be called whenever task is terminated with `tn_task_exit()` or `tn_task_terminate()`.
   * [ ] Should we actually allow to delete mutex while it's hold?
   * [ ] Should we maintain wakeup_count, activate_count?


== modifications of original TNKernel ==

   * timer_task removed (huge performance boost: each timer tick time: ~700 ticks -> ~300 ticks)
   * tn_mutex_lock() behaves just like tn_mutex_lock_polling() if zero timeout was given (instead of returning TERR_WRONG_PARAM)
   * TN_USE_MUTEXES, TN_USE_EVENTS were checked by #ifdef, now they are checked by #if (actually there was an inconsistency: TN_CHECK_PARAM was always checked by #if)

== bug fixes of original TNKernel ==

   * fixed bug in tn_sys_tslice_ticks() : if wrong params were given, interrupts remain disabled
   * fixed minor bug in _tn_task_wait_complete : we don't actually need to check TN_USE_MUTEXES there at all, it is even plain wrong. It doesn't break things because the condition was always false.
   * fixed minor bug: when deleting mutex or semaphore, tn_switch_context was called for each non-suspended task that was waiting for that mutex/sepaphore. It's better to just make them runnable one-by-one without calling tn_switch_context after each one, and switch context just once after all (if needed).
   * fixed bug: if task that waits for mutex was in WAITING_SUSPENDED state, and mutex is deleted, TERR_NO_ERR is returned instead of TERR_DLT.


   
== bad style of original TNKernel ==
   
   * A lot of #if...#endif in the code. examples:
      * in tn_tasks.c, TN_USE_MUTEXES is checked. Now, _unlock_all_mutexes() was added instead
      * #if TN_CHECK_PARAM ... #endif
   * types: all tnkernel structures are hidden by typedef. It is not good idea. 
   * macro TN_CHECK_NON_INT_CONTEXT that returns from the function
   * types: typedef name was in CAPS, so, it looks like a macro.
   * a lot of 'tn_disable_interrupt(); return;' snippets, instead of "one entry, one exit" rule with goto statements.
   * a lot of code duplication. Same tasks are accomplished just by copy-paste, instead of creating function for that. Examples of what I've added instead:
      * _add_entry_to_ready_queue() / _remove_entry_from_ready_queue()
      * _unlock_all_mutexes()
      * task/interrupt/polling versions of functions were implemented separately, instead of provide some kind of wrapper functions that eventually call real worker function. (in tn_tasks.c: tn_task_release_wait/tn_task_irelease_wait, etc)
   * inconsistency in several things
      * TN_CHECK_PARAM was checked by #if,  but TN_USE_MUTEXES, TN_USE_EVENTS were checked by #ifdef

== bad things in TNKernel ==

   * [ ] Is it really good idea that task does have wakeup_count, so you can call tn_task_wakeup before tn_task_sleep, and on the next tn_task_sleep call task won't go to sleep? It seems just like dirty hack to prevent race conditions. This dirty hack makes programmer able to not provide proper syncronization, this is really bad idea IMO. The same with activate_count and tn_task_terminate().
   * [ ] Is it really good idea that we are able to suspend any non-current task? It should be totally up to the task itself when it should sleep and when it shouldn't. If we need to pause some task from outside, we should implement a message to this task, and then task should put itself to sleep.
   * [ ] Even more, is it really good idea that we are able to terminate any task? More, tasks in TNKernel don't even have any callback like "destructor" that should be called when task is terminated. So any non-tnkernel resources (such as memory from heap) that might be held by task will leak.
   * [ ] The rule "one entry point, one exit point" is violated constantly across the whole sources.
   * [ ] Code organization in general is far from perfect: this is just one header file with lots of stuff, including some private-to-tnkernel definitions like task_to_runnable, task_wait_complete etc.

